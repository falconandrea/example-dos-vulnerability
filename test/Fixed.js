const { expect } = require('chai');
const hre = require('hardhat');

describe('Fixed contract', () => {
  it('Shoulder set a new winner', async () => {
    const fixed = await hre.ethers.deployContract('Fixed')
    await fixed.waitForDeployment()

    const [_, address1, address2] = await hre.ethers.getSigners()

    // Set a new winner
    await expect(fixed.connect(address1).setCurrentAuctionPrice({
      value: hre.ethers.parseEther('0.5')
    })).to.be.not.reverted

    // Check the new winner
    let currentWinner = await fixed.currentWinner()
    expect(currentWinner).to.equal(address1.address)

    // Revert if value is less than previous winner
    await expect(fixed.connect(address2).setCurrentAuctionPrice({
      value: hre.ethers.parseEther('0.4')
    })).to.be.revertedWith("Need to pay more than the currentAuctionPrice")

    // New winner
    await expect(fixed.connect(address2).setCurrentAuctionPrice({
      value: hre.ethers.parseEther('0.6')
    })).to.be.not.reverted

    // Check the new winner
    currentWinner = await fixed.currentWinner()
    expect(currentWinner).to.equal(address2.address)
  })

  it('Old winner should be able to withdraw', async () => {
    const fixed = await hre.ethers.deployContract('Fixed')
    await fixed.waitForDeployment()

    const [_, address1, address2] = await hre.ethers.getSigners()

    // Set a new winner
    await expect(fixed.connect(address1).setCurrentAuctionPrice({
      value: hre.ethers.parseEther('0.5')
    })).to.be.not.reverted

    // Check the new winner
    let currentWinner = await fixed.currentWinner()
    expect(currentWinner).to.equal(address1.address)

    // New winner
    await expect(fixed.connect(address2).setCurrentAuctionPrice({
      value: hre.ethers.parseEther('0.6')
    })).to.be.not.reverted

    // Check the new winner
    currentWinner = await fixed.currentWinner()
    expect(currentWinner).to.equal(address2.address)

    // Old winner can withdraw
    await expect(fixed.connect(address1).withdraw()).to.be.not.reverted
  })

  it('Current winner shouldn\'t be able to withdraw', async () => {
    const fixed = await hre.ethers.deployContract('Fixed')
    await fixed.waitForDeployment()

    const [_, address1, address2] = await hre.ethers.getSigners()

    // Set a new winner
    await expect(fixed.connect(address1).setCurrentAuctionPrice({
      value: hre.ethers.parseEther('0.5')
    })).to.be.not.reverted

    // Check the new winner
    let currentWinner = await fixed.currentWinner()
    expect(currentWinner).to.equal(address1.address)

    // Current winner cannot withdraw
    await expect(fixed.connect(address1).withdraw()).to.be.revertedWith("Current winner cannot withdraw")
  })

  it('Attacker shouldn\'t block the next winner', async () => {
    const fixed = await hre.ethers.deployContract('Fixed')
    await fixed.waitForDeployment()

    const attack = await hre.ethers.deployContract('Attack', [fixed.target])
    await attack.waitForDeployment()

    const [_, address1, address2] = await hre.ethers.getSigners()

    // Set a new winner
    await expect(fixed.connect(address1).setCurrentAuctionPrice({
      value: hre.ethers.parseEther('0.5')
    })).to.be.not.reverted

    // Check the new winner
    let currentWinner = await fixed.currentWinner()
    expect(currentWinner).to.equal(address1.address)

    // Attack
    await expect(attack.attack({
      value: hre.ethers.parseEther('1')
    })).to.be.not.reverted

    // Check if the attacker is the new winner
    currentWinner = await fixed.currentWinner()
    expect(currentWinner).to.be.equal(attack.target)

    // Try to change winner
    await expect(fixed.connect(address2).setCurrentAuctionPrice({
      value: hre.ethers.parseEther('1.5')
    })).to.be.not.reverted

    // Check winner if is changed
    currentWinner = await fixed.currentWinner()
    expect(currentWinner).to.be.equal(address2.address)
  })
})
